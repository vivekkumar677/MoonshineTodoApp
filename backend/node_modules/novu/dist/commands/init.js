"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initCommand = exports.ChannelCTATypeEnum = void 0;
const open = require("open");
const ora = require("ora");
const uuid_1 = require("uuid");
const shared_1 = require("@novu/shared");
const client_1 = require("../client");
const init_consts_1 = require("./init.consts");
const server_1 = require("../server");
const constants_1 = require("../constants");
const api_1 = require("../api");
const services_1 = require("../services");
const auth_1 = require("../api/auth");
const chalk = require("chalk");
const domains_1 = require("../constants/domains");
var ChannelCTATypeEnum;
(function (ChannelCTATypeEnum) {
    ChannelCTATypeEnum["REDIRECT"] = "redirect";
})(ChannelCTATypeEnum = exports.ChannelCTATypeEnum || (exports.ChannelCTATypeEnum = {}));
const anonymousId = (0, uuid_1.v4)();
const analytics = new services_1.AnalyticService();
async function initCommand() {
    try {
        await (0, init_consts_1.showWelcomeScreen)();
        const config = new services_1.ConfigService();
        if (process.env.NODE_ENV === 'dev') {
            await config.clearStore();
        }
        const existingEnvironment = await checkExistingEnvironment(config);
        const isSessionExists = config.getDecodedToken();
        analytics.track({
            event: services_1.AnalyticsEventEnum.CLI_LAUNCHED,
            identity: { anonymousId: isSessionExists ? undefined : anonymousId, userId: isSessionExists === null || isSessionExists === void 0 ? void 0 : isSessionExists._id },
            data: {
                existingEnvironment: !!existingEnvironment,
            },
        });
        if (existingEnvironment) {
            const { result } = await (0, client_1.prompt)((0, init_consts_1.existingSessionQuestions)(existingEnvironment));
            const user = config.getDecodedToken();
            analytics.identify(user);
            if (result === 'visitDashboard') {
                await handleExistingSession(result, config);
                return;
            }
            await analytics.flush();
            process.exit();
        }
        await handleOnboardingFlow(config);
    }
    catch (e) {
        console.error(e);
    }
}
exports.initCommand = initCommand;
async function handleOnboardingFlow(config) {
    const httpServer = new server_1.HttpServer();
    await httpServer.listen();
    let spinner = null;
    try {
        const answers = await (0, client_1.prompt)(init_consts_1.introQuestions);
        analytics.track({
            identity: { anonymousId },
            event: services_1.AnalyticsEventEnum.CREATE_APP_QUESTION_EVENT,
        });
        const envAnswer = await (0, client_1.prompt)(init_consts_1.environmentQuestions);
        analytics.track({
            identity: { anonymousId },
            event: services_1.AnalyticsEventEnum.ENVIRONMENT_SELECT_EVENT,
            data: {
                environment: envAnswer.env,
            },
        });
        if (envAnswer.env === 'self-hosted-docker') {
            await open(constants_1.GITHUB_DOCKER_URL);
            await analytics.flush();
            return;
        }
        const regMethod = await (0, client_1.prompt)(init_consts_1.registerMethodQuestions);
        analytics.track({
            identity: { anonymousId },
            event: services_1.AnalyticsEventEnum.REGISTER_METHOD_SELECT_EVENT,
            data: {
                environment: regMethod.value,
            },
        });
        const { accept } = await (0, client_1.prompt)(init_consts_1.termAndPrivacyQuestions);
        analytics.track({
            identity: { anonymousId },
            event: services_1.AnalyticsEventEnum.TERMS_AND_CONDITIONS_QUESTION,
            data: {
                accepted: accept,
            },
        });
        if (accept === false) {
            await analytics.flush();
            process.exit();
        }
        if (regMethod.value === 'github') {
            spinner = ora('Waiting for a brave unicorn to login').start();
            await gitHubOAuth(httpServer, config);
            spinner.stop();
        }
        else if (regMethod.value === 'email') {
            await signUp(config);
        }
        spinner = ora('Setting up your new account').start();
        await createOrganizationHandler(config, answers);
        const user = config.getDecodedToken();
        if (regMethod.value === 'github' && domains_1.privateEmailDomains.includes(user.email.split('@')[1])) {
            analytics.track({
                identity: { anonymousId },
                event: services_1.AnalyticsEventEnum.PRIVATE_EMAIL_ATTEMPT,
                data: {
                    method: 'github',
                },
            });
            spinner.stop();
            let updateErrorForEmail = false;
            do {
                const { domain } = await (0, client_1.prompt)((0, init_consts_1.privateDomainQuestions)(user.email));
                if (domain === 'updateEmail') {
                    const { email } = await (0, client_1.prompt)(init_consts_1.emailQuestion);
                    try {
                        await (0, auth_1.updateEmail)({ email });
                    }
                    catch (e) {
                        const error = e.response.data;
                        updateErrorForEmail = true;
                        console.error('Un-expected error ', error);
                    }
                }
            } while (updateErrorForEmail);
        }
        spinner.start();
        analytics.track({
            identity: { anonymousId },
            event: services_1.AnalyticsEventEnum.ACCOUNT_CREATED,
            data: {
                method: regMethod.value,
            },
        });
        const redirectUrl = `${constants_1.CLIENT_LOGIN_URL}/?token=${config.getToken()}`;
        spinner.succeed(`Your account has been successfully created. 
    
    To help you get started quickly, 
    we've developed a quick start that will guide you through setting up and testing Novu notifications with ease.
    
    In case the browser haven't opened automatically, you can access the quick start here:
    ${chalk.blue(redirectUrl)}
    `);
        httpServer.redirectSuccessDashboard(redirectUrl);
        await exitHandler();
    }
    catch (error) {
        console.error(error);
        spinner === null || spinner === void 0 ? void 0 : spinner.fail('Something un-expected happened :(');
    }
    finally {
        spinner === null || spinner === void 0 ? void 0 : spinner.stop();
        httpServer.close();
    }
}
async function gitHubOAuth(httpServer, config) {
    const redirectUrl = `http://${constants_1.SERVER_HOST}:${await (0, constants_1.getServerPort)()}${constants_1.REDIRECT_ROUTE}`;
    try {
        await open(`${constants_1.API_OAUTH_URL}?&redirectUrl=${redirectUrl}&source=${shared_1.SignUpOriginEnum.CLI}&distinctId=${anonymousId}`);
        const userJwt = await httpServer.redirectResponse();
        storeToken(config, userJwt);
    }
    catch (error) {
        console.error(error);
    }
}
async function createOrganizationHandler(config, answers) {
    if (config.isOrganizationIdExist())
        return;
    const createOrganizationResponse = await (0, api_1.createOrganization)(answers.environmentName);
    const newUserJwt = await (0, api_1.switchOrganization)(createOrganizationResponse._id);
    storeToken(config, newUserJwt);
}
async function createEnvironmentHandler(config, answers) {
    var _a;
    if (config.isEnvironmentIdExist()) {
        const existingEnvironment = await (0, api_1.getEnvironmentMe)();
        const keys = await (0, api_1.getEnvironmentApiKeys)();
        config.setValue('apiKey', (_a = keys[0]) === null || _a === void 0 ? void 0 : _a.key);
        return existingEnvironment.identifier;
    }
    const createEnvironmentResponse = await (0, api_1.createEnvironment)(answers.environmentName);
    const newUserJwt = await (0, api_1.switchEnvironment)(createEnvironmentResponse._id);
    config.setValue('apiKey', createEnvironmentResponse.apiKeys[0].key);
    storeToken(config, newUserJwt);
    return createEnvironmentResponse.identifier;
}
function storeToken(config, userJwt) {
    config.setValue('token', userJwt);
    (0, api_1.storeHeader)('authorization', `Bearer ${config.getToken()}`);
}
async function exitHandler() {
    await keyPress();
}
const keyPress = async () => {
    return new Promise((resolve) => process.stdin.once('data', () => {
        resolve();
    }));
};
async function checkExistingEnvironment(config) {
    const isSessionExists = !!config.getDecodedToken();
    if (isSessionExists && process.env.NODE_ENV !== 'dev') {
        storeToken(config, config.getToken());
        let existingEnvironment;
        try {
            existingEnvironment = await (0, api_1.getEnvironmentMe)();
            if (!existingEnvironment) {
                return null;
            }
        }
        catch (e) {
            await config.clearStore();
            return null;
        }
        return existingEnvironment;
    }
    return null;
}
async function handleExistingSession(result, config) {
    if (result === 'visitDashboard') {
        analytics.track({
            identity: { userId: config.getDecodedToken()._id },
            event: services_1.AnalyticsEventEnum.OPEN_DASHBOARD,
            data: {
                existingUser: true,
            },
        });
        const dashboardURL = `${constants_1.CLIENT_LOGIN_URL}?token=${config.getToken()}&source=${shared_1.SignUpOriginEnum.CLI}`;
        await open(dashboardURL);
    }
    else if (result === 'exit') {
        analytics.track({
            identity: { userId: config.getDecodedToken()._id },
            event: services_1.AnalyticsEventEnum.EXIT_EXISTING_SESSION,
        });
        await analytics.flush();
        process.exit();
    }
}
async function signUp(config) {
    var _a, _b;
    let errorInSignup = true;
    const { fullName } = await (0, client_1.prompt)(init_consts_1.fullNameQuestion);
    while (errorInSignup) {
        const { email } = await (0, client_1.prompt)(init_consts_1.emailQuestion);
        if (domains_1.privateEmailDomains.includes(email.split('@')[1])) {
            analytics.track({
                identity: { anonymousId },
                event: services_1.AnalyticsEventEnum.PRIVATE_EMAIL_ATTEMPT,
                data: {
                    method: 'email',
                },
            });
            const { domain } = await (0, client_1.prompt)((0, init_consts_1.privateDomainQuestions)(email));
            if (domain === 'updateEmail') {
                errorInSignup = true;
                continue;
            }
        }
        const { password } = await (0, client_1.prompt)(init_consts_1.passwordQuestion);
        try {
            const response = await (0, auth_1.signup)({
                email,
                password,
                firstName: fullName.split(' ')[0],
                lastName: fullName.split(' ')[1] || '',
                origin: shared_1.SignUpOriginEnum.CLI,
            });
            storeToken(config, response.token);
            errorInSignup = false;
        }
        catch (e) {
            const error = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.data;
            if ((error === null || error === void 0 ? void 0 : error.message) === 'User already exists') {
                const { proceedSignup } = await (0, client_1.prompt)(init_consts_1.proceedSignupQuestions);
                if (proceedSignup === 'resetPassword') {
                    await open(`${constants_1.CLIENT_LOGIN_URL.replace('/auth/login', '/auth/reset/request')}`);
                    console.log('Finished flow');
                    process.exit();
                }
                else {
                    errorInSignup = true;
                }
            }
            else {
                errorInSignup = true;
                console.log(chalk.bold.red(Array.isArray(error === null || error === void 0 ? void 0 : error.message) ? (_b = error === null || error === void 0 ? void 0 : error.messag) === null || _b === void 0 ? void 0 : _b.join('\n') : (error === null || error === void 0 ? void 0 : error.message) || 'Something went wrong'));
            }
        }
    }
}
//# sourceMappingURL=init.js.map